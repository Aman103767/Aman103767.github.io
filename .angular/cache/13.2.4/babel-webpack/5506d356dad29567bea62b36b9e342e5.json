{"ast":null,"code":"import { Injectable, Directive, ElementRef, Renderer2, Input, NgModule } from '@angular/core';\nimport { Subscription, fromEvent, EMPTY } from 'rxjs';\nimport { CommonModule } from '@angular/common';\nimport * as ɵngcc0 from '@angular/core';\nlet ScrollService = /*#__PURE__*/(() => {\n  class ScrollService {\n    constructor() {\n      this.scrollSub = new Subscription();\n      this.resizeSub = new Subscription(); // set initial value\n\n      this.manageScrollPos(); // create observable that we can subscribe to from component or directive\n\n      this.scrollObs = typeof window !== \"undefined\" ? fromEvent(window, \"scroll\") : EMPTY; // initiate subscription to update values\n\n      this.scrollSub = this.scrollObs.subscribe(() => this.manageScrollPos()); // create observable for changes in screen size\n\n      this.resizeObs = typeof window !== \"undefined\" ? fromEvent(window, \"resize\") : EMPTY; // initiate subscription to update values\n\n      this.resizeSub = this.resizeObs.subscribe(() => this.manageScrollPos());\n    }\n\n    manageScrollPos() {\n      // update service property\n      this.pos = typeof window !== \"undefined\" ? window.pageYOffset : 0;\n    }\n\n    ngOnDestroy() {\n      this.scrollSub.unsubscribe();\n      this.resizeSub.unsubscribe();\n    }\n\n  }\n\n  ScrollService.ɵfac = function ScrollService_Factory(t) {\n    return new (t || ScrollService)();\n  };\n\n  ScrollService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: ScrollService,\n    factory: ScrollService.ɵfac\n  });\n  return ScrollService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet AnimateOnScrollDirective = /*#__PURE__*/(() => {\n  class AnimateOnScrollDirective {\n    constructor(elementRef, renderer, scroll) {\n      this.elementRef = elementRef;\n      this.renderer = renderer;\n      this.scroll = scroll;\n      this.scrollSub = new Subscription();\n      this.resizeSub = new Subscription(); // Pixel offset from screen bottom to the animated element to determine the start of the animation\n\n      this.offset = 80; // for scroll Listener\n    }\n\n    get id() {\n      return this.elementRef.nativeElement.id;\n    }\n\n    ngOnInit() {\n      if (!this.animationName) {\n        return;\n      } // default visibility to false\n\n\n      this.isVisible = false;\n      this.useScroll = this.useScroll ? this.useScroll : this.useScroll === false ? false : true;\n      this.threshold = this.threshold ? this.threshold || 0.5 : 0.5; // using intersecting observer by default, else fallback to scroll Listener\n\n      if (\"IntersectionObserver\" in window && this.useScroll) {\n        const options = {\n          root: null,\n          threshold: this.threshold,\n          rootMargin: \"0px\"\n        };\n        const observer = new IntersectionObserver((entries, _) => {\n          entries.forEach(entry => {\n            if (!entry.isIntersecting) {\n              return;\n            }\n\n            this.addAnimationClass();\n          });\n        }, options);\n        observer.observe(this.elementRef.nativeElement);\n        return;\n      } // subscribe to scroll event using service\n\n\n      this.scrollSub = this.scroll.scrollObs.subscribe(() => this.manageVisibility()); // subscribe to resize event using service so scrolling position is always accurate\n\n      this.resizeSub = this.scroll.resizeObs.subscribe(() => this.manageVisibility());\n    }\n\n    ngAfterViewInit() {\n      // run visibility check initially in case the element is already visible in viewport\n      setTimeout(() => this.manageVisibility(), 1);\n    }\n\n    ngOnDestroy() {\n      this.scrollSub.unsubscribe();\n      this.resizeSub.unsubscribe();\n    }\n    /**\n     * check for visibility of element in viewport to add animation\n     *\n     * @returns void\n     */\n\n\n    manageVisibility() {\n      if (this.isVisible) {\n        // Optimisation; nothing to do if class has already been applied\n        return;\n      } // check for window height, may change with a window resize\n\n\n      this.getWinHeight(); // get vertical position for selected element\n\n      this.getOffsetTop(); // we should trigger the addition of the animation class a little after getting to the element\n\n      const scrollTrigger = this.offsetTop + this.offset - this.winHeight; // using values updated in service\n\n      if (this.scroll.pos >= scrollTrigger) {\n        this.addAnimationClass();\n      }\n    }\n    /**\n     * utility function to mark element visible and add css class\n     *\n     * @returns void\n     */\n\n\n    addAnimationClass() {\n      // stops execution if no class is provided\n      if (!this.animationName) {\n        return;\n      } // mark this element visible, we won't remove the class after this\n\n\n      this.isVisible = true; // use default for animate.css if no value provided\n\n      this.setClass(this.animationName);\n    }\n    /**\n     * utility function to add one or more css classes to element in DOM\n     *\n     * @param  {string} classes\n     * @returns void\n     */\n\n\n    setClass(classes) {\n      for (const c of classes.split(\" \")) {\n        this.renderer.addClass(this.elementRef.nativeElement, c);\n      }\n    }\n    /**\n     * get window height utility function\n     *\n     * @returns void\n     */\n\n\n    getWinHeight() {\n      this.winHeight = typeof window !== \"undefined\" ? window.innerHeight : 0;\n    }\n    /**\n     * get offsetTop value for element\n     *\n     * @returns void\n     */\n\n\n    getOffsetTop() {\n      if (typeof this.elementRef.nativeElement.getBoundingClientRect === \"function\") {\n        const viewportTop = this.elementRef.nativeElement.getBoundingClientRect().top;\n        const clientTop = this.elementRef.nativeElement.clientTop; // get vertical position for selected element\n\n        this.offsetTop = viewportTop + this.scroll.pos - clientTop;\n      } else {\n        this.offsetTop = 0;\n      }\n    }\n\n  }\n\n  AnimateOnScrollDirective.ɵfac = function AnimateOnScrollDirective_Factory(t) {\n    return new (t || AnimateOnScrollDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ScrollService));\n  };\n\n  AnimateOnScrollDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: AnimateOnScrollDirective,\n    selectors: [[\"\", \"animateOnScroll\", \"\"]],\n    inputs: {\n      offset: \"offset\",\n      useScroll: \"useScroll\",\n      threshold: \"threshold\",\n      animationName: \"animationName\"\n    }\n  });\n  return AnimateOnScrollDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet AnimateOnScrollModule = /*#__PURE__*/(() => {\n  class AnimateOnScrollModule {\n    static forRoot() {\n      return {\n        ngModule: AnimateOnScrollModule,\n        providers: [ScrollService]\n      };\n    }\n\n  }\n\n  AnimateOnScrollModule.ɵfac = function AnimateOnScrollModule_Factory(t) {\n    return new (t || AnimateOnScrollModule)();\n  };\n\n  AnimateOnScrollModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: AnimateOnScrollModule\n  });\n  AnimateOnScrollModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return AnimateOnScrollModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AnimateOnScrollModule, {\n    declarations: function () {\n      return [AnimateOnScrollDirective];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [AnimateOnScrollDirective];\n    }\n  });\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AnimateOnScrollDirective, AnimateOnScrollModule, ScrollService }; //# sourceMappingURL=ng2-animate-on-scroll.js.map","map":null,"metadata":{},"sourceType":"module"}